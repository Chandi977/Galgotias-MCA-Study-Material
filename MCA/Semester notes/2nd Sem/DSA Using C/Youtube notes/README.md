# Learning Plan: Data Structures and Algorithms (DSA)

## Description
This learning plan aims to provide a structured approach to learning Data Structures and Algorithms (DSA) for beginners. It covers fundamental concepts, common data structures, algorithm design techniques, and problem-solving strategies.

# Table of Contents

1. [Introduction](#introduction)
    - [Definition of Data Structures](#definition-of-data-structures)
    - [Types of Data Structures](#types-of-data-structures)

2. [Operations on Linear Data Structures](#operations-on-linear-data-structures)
    - [Access](#access)
    - [Insertion](#insertion)
    - [Deletion](#deletion)
    - [Traversal](#traversal)
    - [Search](#search)
    - [Update](#update)
    - [Sorting](#sorting)
    - [Merging](#merging)

3. [Real-world Examples of Linear Data Structures](#real-world-examples-of-linear-data-structures)
    - [Arrays](#arrays)
    - [Linked Lists](#linked-lists)
    - [Stacks](#stacks)
    - [Queues](#queues)
    - [Deques (Double-Ended Queues)](#deques-double-ended-queues)

4. [Non-Linear Data Structures](#non-linear-data-structures)
    - [Tree](#tree)
    - [Graph](#graph)
    - [Heap](#heap)

5. [Guided Path Overview](#guided-path-overview)
    - [Introduction to DSA](#introduction-to-dsa)
    - [Arrays](#arrays-1)
    - [Linked Lists](#linked-lists-1)
    - [Recursion](#recursion)
    - [Sorting](#sorting-1)
    - [Binary Search](#binary-search)
    - [Trees](#trees)
    - [Backtracking](#backtracking)
    - [Hashing](#hashing)
    - [Graphs](#graphs)
    - [Dynamic Programming](#dynamic-programming)
    - [Bit Manipulation](#bit-manipulation)
    - [Practice Questions](#practice-questions)

# Guided Path to Data Structures and Algorithms (DSA)

## Introduction

Data structures are fundamental concepts in computer science that involve the organization, storage, and manipulation of data. They provide a systematic way to store and manage information, making it accessible and efficient to work with. Data structures are the building blocks of algorithms and play a crucial role in software development.

### Types of Data Structures

- **Linear Data Structures**
  - Array
  - Linked List
  - Stack
  - Queue
  - Deque

- **Non-linear Data Structures**
  - Tree
  - Graph
  - Heap

## Operations on Linear Data Structures

- Access
- Insertion
- Deletion
- Traversal
- Search
- Update
- Sorting
- Merging

## Real-world Examples of Linear Data Structures

### Arrays

- Grocery Shopping List
- Image Pixels

### Linked Lists

- Music Playlist
- Train Cars

### Stacks

- Undo Feature
- Plate Stacking

### Queues

- Cafeteria Line
- Ticket Counter

### Deques (Double-Ended Queues)

- Sliding Glass Doors
- Printing and Scanning

## Non-Linear Data Structures

- **Tree**
  - Hierarchical structure with nodes connected by edges, commonly used for organizing hierarchical data like file systems.

- **Graph**
  - Collection of nodes connected by edges, allowing versatile representation of relationships between various entities.

- **Heap**
  - Specialized tree-based structure that satisfies the heap property, often used in priority queues and memory allocation.

### The Need for Non-Linear Data Structures

- Complex Relationships
- Hierarchical Organization
- Graph-based Modeling
- Efficient Priority Management

## Guided Path Overview

1. Introduction to DSA
2. Arrays
3. Linked Lists
4. Recursion
5. Sorting
6. Binary Search
7. Trees
8. Backtracking
9. Hashing
10. Graphs
11. Dynamic Programming
12. Bit Manipulation
13. Practice Questions

### Benefits of This Guided Path

- Structured Learning
- Multilingual Approach
- Hands-On Practice
- Adaptable for All Levels
- 
![Intro](https://github.com/Chandi977/Galgotias-MCA-Study-Material/assets/55855799/cfaccfbf-7392-4600-b337-a6968ce4b53f)


## Linear Data Structures
[Explain linear data structures such as arrays, linked lists, stacks, queues, and deques. Cover their properties, operations, and implementation details]

## Non-linear Data Structures
[Discuss non-linear data structures like trees, heaps, and graphs. Explore their characteristics, traversal methods, and common applications]

## Algorithm Analysis
[Introduce the basics of algorithm analysis, including time and space complexity, Big O notation, and asymptotic notation]

## Sorting and Searching Algorithms
[Examine popular sorting algorithms like Bubble Sort, Merge Sort, and Quick Sort. Also, cover searching algorithms like Linear Search and Binary Search]

## Graph Algorithms
[Explore graph algorithms, including depth-first search (DFS), breadth-first search (BFS), minimum spanning trees (Prim's and Kruskal's algorithms), and shortest path algorithms (Dijkstra's algorithm)]

## Dynamic Programming
[Introduce dynamic programming concepts and techniques for solving optimization problems. Cover memoization, tabulation, and common dynamic programming problems]


### Operations on Linear Data Structures

- **Access:** Retrieving elements by index, position, or pointer.
- **Insertion:** Adding new elements at specific positions.
- **Deletion:** Removing elements from specific positions.
- **Traversal:** Iterating through elements sequentially.
- **Search:** Finding the position or existence of an element.
- **Update:** Modifying the value of an element.
- **Sorting:** Arranging elements in a specified order.
- **Merging:** Combining two ordered linear structures.

### Real-world Examples of Linear Data Structures

# Arrays:
![array](https://github.com/Chandi977/Galgotias-MCA-Study-Material/assets/55855799/b3d60afd-6983-442c-bb4f-f7037bfeb158)

- Grocery Shopping List: Managing your shopping list with each item corresponding to an array index simplifies adding, removing, and checking off items.
- Image Pixels: In digital images, arrays store pixel values, allowing manipulation and editing of pictures by altering individual pixel colours.

# Linked Lists:
![linkedlist](https://github.com/Chandi977/Galgotias-MCA-Study-Material/assets/55855799/22d19f78-fad1-45d4-b520-2139a7e921ba)

- Music Playlist: Linked lists are suitable for creating playlists, where songs are nodes connected in a sequence, allowing easy rearrangement and modification.
- Train Cars: Linked lists can represent train cars linked together, enabling efficient addition and removal of cars without affecting the entire train.

# Stacks:
![stack](https://github.com/Chandi977/Galgotias-MCA-Study-Material/assets/55855799/a24d6430-93c8-480c-8ff5-0b95a9083b4d)

- Undo Feature: In software applications, stacks manage to undo operations, enabling users to reverse actions in the order they were performed.
- Plate Stacking: Plates stacked on top of each other represent a real-world example of a stack, where the last plate placed is the first one taken.

# Queues:
![queue](https://github.com/Chandi977/Galgotias-MCA-Study-Material/assets/55855799/e4389832-f95a-4eb5-9545-333cf9809ade)

- Cafeteria Line: Queues model waiting in line at a cafeteria, where the first person in line is served first, maintaining order and fairness.
- Ticket Counter: Waiting in line to purchase tickets, like at a cinema or an event, follows the queue concept.

# Deques (Double-Ended Queues):
![dqueue](https://github.com/Chandi977/Galgotias-MCA-Study-Material/assets/55855799/b65cafbf-6cc9-4019-a129-bf410bb90d5c)

- Sliding Glass Doors: Deques are similar to sliding glass doors at entrances, allowing people to enter or exit from both sides.
- Printing and Scanning: Deques mimic the process of loading and unloading papers for printing and scanning, as both ends are accessible.

### Non-Linear Data Structures

Non-linear data structures do not follow a sequential order; each element can connect to multiple elements, forming complex relationships.

**The following data structures are considered non-linear data structures:**
- **Tree:** A hierarchical structure with nodes connected by edges, commonly used for organizing hierarchical data like file systems.
- **Graph:** A collection of nodes connected by edges, allowing versatile representation of relationships between various entities.
- **Heap:** A specialized tree-based structure that satisfies the heap property, often used in priority queues and memory allocation.

### The Need for Non-Linear Data Structures

- **Complex Relationships:** Non-linear structures represent intricate relationships between elements, suitable for scenarios with intricate connections.
- **Hierarchical Organization:** Trees organize data hierarchically, making them ideal for structures like company organization charts.
- **Graph-based Modeling:** Graphs enable modelling of various real-world networks, from social connections to computer networks.
- **Efficient Priority Management:** Heaps efficiently manage priority-based operations, such as extracting the highest-priority element.


## Operations on Non-Linear Data Structures:

- **Tree Traversal:** Navigating trees using methods like in-order, pre-order, and post-order traversal.
- **Graph Traversal:** Exploring graphs through traversal algorithms like breadth-first search (BFS) and depth-first search (DFS).
- **Heap Operations:** Performing heap-specific operations like insertion, deletion, and heapifying.
- **Balancing:** Ensuring balanced trees, like AVL or Red-Black trees, for efficient search and insertion operations.

## Real-world Examples of Non-Linear Data Structures:

# Tree:
![tree](https://github.com/Chandi977/Galgotias-MCA-Study-Material/assets/55855799/9d41c974-fd22-4e33-b59e-216c8226cc28)
  - File System: Orga
nizing files in a hierarchical structure mirrors the tree concept.
  - Family Genealogy: Representing family relationships, like a family tree.
    
  # Graph:

  ![graph](https://github.com/Chandi977/Galgotias-MCA-Study-Material/assets/55855799/428487c7-d3cf-45c8-85df-9615724910c9)

  - Social Networks: Social media platforms model users and their connections.
  - Road Networks: Maps utilize graphs to represent roads and intersections.
 # Heap:

  ![heap](https://github.com/Chandi977/Galgotias-MCA-Study-Material/assets/55855799/de0a24a7-e7c7-428c-a92a-6cf542e7f4e2)

  - Priority Queue: A hospital's patient queue modeled using a heap.
  - Memory Allocation: The memory heap in programming languages allocates memory dynamically.

## Choosing the Right Data Structure:

### Factors Influencing Data Structure Selection:

- **Data Characteristics:** Type, size, and nature of the data.
- **Operations and Usage:** Identifying primary operations and their frequency.
- **Memory and Storage Constraints:** Evaluating memory availability and storage needs.
- **Access Patterns:** Recognizing access patterns, whether sequential, random, or specific.
- **Algorithmic Requirements:** Considering algorithms that will interact with the chosen structure.

### Common Data Structure Selection Scenarios:

- **Search Operations**
- **Insertion and Deletion**
- **Ordered Data**
- **Memory Efficiency**
- **Frequent Access**

## Guided Path to Data Structures and Algorithms (DSA):

- Introduction to DSA
- Array
- Linked List
- Recursion
- Sorting
- Binary Search
- Trees
- Backtracking
- Hashing
- Graphs
- Dynamic Programming
- Bit Manipulation

## Benefits of This Guided Path:

- Structured Learning
- Multilingual Approach
- Hands-On Practice
- Adaptable for All Levels

# Array Types: Based on Dimensions

## Single Dimensional Arrays

Single dimensional arrays store elements linearly in contiguous memory locations, utilizing a single dimension. They are denoted as `Array_Name[]`.

![array](https://github.com/Chandi977/Galgotias-MCA-Study-Material/assets/55855799/d5182819-6803-4a7a-ba58-b5ddb78e672e)

## Multi-Dimensional Arrays

Arrays with more than one dimension are termed multiple-dimensional arrays. The most common multi-dimensional arrays are 2D and 3D arrays.

### Two-dimensional arrays
![2darray](https://github.com/Chandi977/Galgotias-MCA-Study-Material/assets/55855799/135ce178-cc22-482a-abf2-b20c6294d863)

2D arrays provide a tabular representation by arranging elements in rows (i) * columns (j). For example, `A[2][3]` will have 2 rows and 3 columns, allocating 6 elements. The array starts from `A[0][0]`.

### Three Dimensional Arrays

A 3D array extends a 2D array by adding a depth dimension. It's denoted as `A[k][i][j]`, where k, i, j represent depth, rows, and columns, respectively.

## Properties of Arrays

![properties_of_arrays](https://github.com/Chandi977/Galgotias-MCA-Study-Material/assets/55855799/d8e4a3f8-0cec-4813-9180-8b953a203d01)

- Each array element is of the same data type and size. For example, for an array of integers with the `int` data type, each element occupies 4 bytes.
- Elements of the array are stored in contiguous memory locations. For instance, if 200 is the starting address (base address) assigned to the first element, each subsequent element follows in memory.

## Accessing Array Elements

![arrayTraversal](https://github.com/Chandi977/Galgotias-MCA-Study-Material/assets/55855799/aa7c3150-0e1f-4776-9dee-a9b651e64770)

![traversal](https://github.com/Chandi977/Galgotias-MCA-Study-Material/assets/55855799/8f3e3c18-7e54-4636-bbb1-a41b79f6a38c)

- Elements are accessed using their index, which ranges from 0 to N-1 for an array of size N. For example, accessing element at index 5: `Array[5]`.
- Every array is identified by its base address, i.e., the location of the first element. Hence, the base address helps identify the address of all array elements. For instance, the address of the element at index 4 will be `200 + 4 * (sizeof(int)) = 216`.

## Where Can Arrays be Used?

- Arrays should be used when the number of elements to be stored is known.
- They are commonly used in programs to organize data for sorting or searching.
- Arrays provide high-speed access times (O(1)) and work well for multidimensional data organization.
- Efficient modification of elements is possible when the index is known beforehand.

## Disadvantages of Arrays

- Fixed-size nature makes dynamic alteration of sizes impossible.
- Insertion and deletion operations are costly due to the need for shifting elements.
- Improper memory allocation leads to wastage or inadequate allocation.

## Time Complexity of Various Operations

- Accessing elements: O(1)
- Inserting elements:
  - At the end: O(1)
  - At index i: O(N - i)
  - At the beginning: O(N)

 ![complexity_chart](https://github.com/Chandi977/Galgotias-MCA-Study-Material/assets/55855799/0c9eeafc-39e9-4c70-a3a9-cf59ccfdda20)


# Array Operations and Complexity Analysis

## Finding Elements

Finding an element in an array takes O(N) time in the worst case, where N is the size of the array, as you may need to traverse the entire array.

```c
#include <iostream>

// Function to perform linear search
int linearSearch(int arr[], int n, int target) {
    for (int i = 0; i < n; ++i) {
        if (arr[i] == target) {
            return i; // Return index if element is found
        }
    }
    return -1; // Return -1 if element is not found
}

int main() {
    int arr[] = {1, 3, 5, 7, 9, 11, 13, 15};
    int n = sizeof(arr) / sizeof(arr[0]); // Calculate array size
    int target = 7;

    int index = linearSearch(arr, n, target);
    if (index != -1) {
        std::cout << "Element found at index: " << index << std::endl;
    } else {
        std::cout << "Element not found in the array" << std::endl;
    }

    return 0;
}

```

## Deleting Elements

Deletion of elements:
- Deletion from the end: O(1) time.
- Deletion from beginning or any index: Involves shifting elements to the left.
- Deleting at index i: O(N - i) time.
- Deleting from the beginning: O(N) time.

```c
#include <iostream>

// Function to delete an element from an array
void deleteElement(int arr[], int& size, int index) {
    if (index < 0 || index >= size) {
        std::cout << "Invalid index!" << std::endl;
        return;
    }

    // Shift elements to the left starting from the index
    for (int i = index; i < size - 1; ++i) {
        arr[i] = arr[i + 1];
    }

    // Decrease the size of the array
    --size;
}

int main() {
    int arr[] = {10, 20, 30, 40, 50};
    int size = sizeof(arr) / sizeof(arr[0]);

    int index = 2; // Index of the element to delete

    std::cout << "Array before deletion:" << std::endl;
    for (int i = 0; i < size; ++i) {
        std::cout << arr[i] << " ";
    }
    std::cout << std::endl;

    deleteElement(arr, size, index);

    std::cout << "Array after deletion:" << std::endl;
    for (int i = 0; i < size; ++i) {
        std::cout << arr[i] << " ";
    }
    std::cout << std::endl;

    return 0;
}

```

## Static & Dynamic Arrays

![staticandDynamicArrays](https://github.com/Chandi977/Galgotias-MCA-Study-Material/assets/55855799/003340ed-2e3b-44be-b9bb-a86c4c9164aa)


### Static Arrays

- Fixed-size; cannot change after creation.
- Memory allocated remains unchanged.
- Often called fixed-length or fixed arrays.
- Created on the stack.
- Automatically deleted after going out of scope.

#### Big O Notations for Static Arrays

- Space: O(N)
- Lookup: O(1)
- Append: O(1)
- Insert: O(N)
- Delete: O(N)

```c
#include <iostream>

int main() {
    // Define a static array of integers with size 5
    int arr[5] = {10, 20, 30, 40, 50};

    // Print the elements of the array
    std::cout << "Elements of the array:" << std::endl;
    for (int i = 0; i < 5; ++i) {
        std::cout << arr[i] << " ";
    }
    std::cout << std::endl;

    return 0;
}

Elements of the array:
10 20 30 40 50

```

### Dynamic Arrays

- Size can change after creation.
- Memory allocation can grow or shrink.
- Created on the heap.
- Must be manually deleted when no longer needed.

#### Big O Notations for Dynamic Arrays

- Space: O(N)
- Lookup: O(1)
- Append: O(N)
- Insert: O(N)
- Delete: O(N)

```c
#include <iostream>

int main() {
    // Define the size of the dynamic array
    int size;
    std::cout << "Enter the size of the array: ";
    std::cin >> size;

    // Dynamically allocate memory for the array
    int* arr = new int[size];

    // Input elements into the array
    std::cout << "Enter " << size << " elements:" << std::endl;
    for (int i = 0; i < size; ++i) {
        std::cin >> arr[i];
    }

    // Print the elements of the array
    std::cout << "Elements of the array:" << std::endl;
    for (int i = 0; i < size; ++i) {
        std::cout << arr[i] << " ";
    }
    std::cout << std::endl;

    // Free the dynamically allocated memory
    delete[] arr;

    return 0;
}

```

## Complexity Analysis and Big O Notation

Big O notation expresses algorithmic complexity relative to input size. Here are common Big O notations:
- O(1): Constant Time
- O(log N): Logarithmic Time
- O(N): Linear Time
- O(N^2): Quadratic Time

## Traversal in an Array

Traversal involves visiting each array element sequentially. It's useful for counting, printing, changing values, etc.

![traversal](https://github.com/Chandi977/Galgotias-MCA-Study-Material/assets/55855799/0ab59034-99e0-4554-a06f-60331a4614c3)


```cpp
#include<iostream>
using namespace std;
int main() { 
   int array[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }; 
   for (int i = 0; i < 10; i++) { 
       cout << array[i]; 
   } 
   return 0; 
}
```

```cpp

#include <iostream>
using namespace std;

int main() {

   int* intArray = new int[4];
   intArray[0] = 5;
   intArray[1] = 6;
   intArray[2] = 7;
   intArray[3] = 8;
   cout << "Array Elements: ";
   for (int j = 0; j < 4; j++) {
       cout << intArray[j];
       cout << " ";
   }
   delete[] intArray;
  
   return 0;
}
```

# Algorithmic Complexity and Array Traversal

## Key Concepts

1. **Algorithm**: A step-by-step procedure for solving a problem. For instance, sorting a list of numbers using an algorithm like quicksort.

2. **Input Size**: The amount of data an algorithm works with. For sorting algorithms, it's the number of items in the list. Complexity analysis helps understand how algorithms behave as input size grows.

3. **Efficiency**: Describes how efficiently an algorithm uses resources like time and memory. Complexity analysis quantifies this efficiency.

## Big O Notation

Big O notation simplifies an algorithm's behavior relative to input size, expressed as "O" followed by an expression. Common notations include:
- **O(1)**: Constant Time
- **O(log n)**: Logarithmic Time
- **O(n)**: Linear Time
- **O(n^2)**: Quadratic Time

It's crucial to choose algorithms with minimal Big O complexity for efficient processing, especially with large data.

## Traversal in an Array

Traversal involves visiting each element of an array sequentially. Operations like counting, printing, and modifying elements are possible through traversal.

```cpp
int main() {
   int array[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
   for (int i = 0; i < 10; i++) {
       cout << array[i];
   }
   return 0;
}
```
 
```cpp
int main() 
{ 
   // Declare the array with the size and the array elements 
   int array[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }; 
   // Declare a flag variable and initialise it to 0 
   int flag = 0; 
 
   // Iterate through the array and compare each element of the array to the item 
   for (int i = 0; i < 10; i++) { 
          cout<<array[i];
   } 
      return 0; 
}
 ```

Output:
1 2 3 4 5 6 7 8 9 10
 

# Searching an Element in an Array

There are various search algorithms available to find an element in an array, including Linear Search, Binary Search, Hash Table (Dictionary), etc.

The most basic search algorithm is linear search, where we find an element by traversing each index from the first to the last.

## Linear Search

Suppose there are N numbers in an array, and we have to search for a specific number num.

Let's code a program to find an element in a given array:

```cpp
#include <iostream> 
using namespace std; 

int main() { 
    // Declare the array with the size and the array elements 
    int array[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}; 

    // Declare the element to be searched 
    int item; 
    cout << "Enter the item to be searched: "; 
    cin >> item; 

    // Declare a flag variable and initialize it to 0 
    int flag = 0; 

    // Iterate through the array and compare each element of the array to the item 
    for (int i = 0; i < 10; i++) { 
        if (array[i] == item) { 
            // If the item is found, set the flag to 1 
            flag = 1; 
            break; 
        } 
    } 

    // Check the flag value 
    if (flag == 1) 
        cout << "Item found"; 
    else
        cout << "Item not found"; 

    return 0; 
}
```

# Insertion and Deletion in Arrays

## Insertion of an Element in an Array

Elements can be inserted anywhere in an array, including the beginning, middle, end, or elsewhere. The positions or index locations are increased once the element is added, but this doesn't imply the array size is growing.

Let's code a program to insert an element in a given array:

```c
int main() {
    int arr[size] = {1, 20, 5, 78, 30};
    int element, pos, i;
    printf("Enter position and element\n");
    scanf("%d%d", &pos, &element);
    if (pos <= size && pos >= 0) {
        // Shift all elements from the last index to pos by 1 position to the right
        for (i = size; i > pos; i--)
            arr[i] = arr[i - 1];
        // Insert element at the given position
        arr[pos] = element;
        for (i = 0; i <= size - 1; i++)
            printf("%d ", arr[i]);
    } else
        printf("Invalid Position\n");
    return 0;
}
```

### Deletion of an Element in an Array
To delete a specific element from an array, we traverse and search for that element. The deletion doesn't affect the array size. We also need to check whether deletion is possible.

Let's code a program to delete an element in a given array:
Real-time Examples of Arrays in Coding Problems-

```c
int main() {
    int arr[size] = {1, 20, 5, 78, 30};
    int key, i, index = -1;
    printf("Enter element to delete\n");
    scanf("%d", &key);
    // Iterate the array elements using loop
    // If any element matches the key, store the index
    for (i = 0; i < size; i++) {
        if (arr[i] == key) {
            index = i;
            break;
        }
    }
    if (index != -1) {
        // Shift all elements from index+1 by one position to the left
        for (i = index; i < size - 1; i++)
            arr[i] = arr[i + 1];
        printf("New Array : ");
        for (i = 0; i < size - 1; i++)
            printf("%d ", arr[i]);
    } else
        printf("Element Not Found\n");
    return 0;
}
```

# Real-World Applications of Arrays

Arrays are fundamental data structures in programming, used in various real-time scenarios:

## Data Storage

- **Lists and Databases**: Storing data like names, email addresses, or records in a database.

## Matrix Operations

- **Matrix Multiplication**: Performing operations on matrices in linear algebra or computer graphics.

## Counting and Tracking

- **Frequency Count**: Counting occurrences of elements, like letters in a string.
- **Tracking Stock Prices**: Storing historical data of stock prices over time.

## Image Processing

- **Pixel Manipulation**: Manipulating pixels in image processing, such as filtering or blurring.

## Game Development

- **2D Game Grids**: Managing game objects and their positions on a grid, e.g., chess or tic-tac-toe.

## Histograms

- **Color Histograms**: Visualizing data distribution, often used in image processing or data analysis.

## Simulation

- **Traffic Simulation**: Modeling traffic flow using arrays to represent lanes and vehicles.

## Geographic Information Systems (GIS)

- **Storing Spatial Data**: Representing geographic coordinates for spatial analysis.

## Audio Processing

- **Audio Samples**: Storing audio samples for processing tasks like filtering or compression.

# Strings

Strings are another type of data structure used for storing and manipulating text data.

## Keyboard Input and Display

Ever wondered how text typed on a keyboard is stored and displayed on the screen? It's managed using strings.


 

# Strings: A Fundamental Data Structure

In programming, a string is an array that can only store characters. Characters are enclosed in single quotes and are a primitive data type in most programming languages (e.g., 'a', 'z', '@').

To define a string, we enclose it in double quotes. Each character in a string is enclosed in single quotes.

Example:
- `123` is treated as an integer.
- `"123"` is treated as a string. Each individual character ('1', '2', '3') can be represented as a character.

The last character of a string is always a null character, written as `'\0'`. Advantages of the null character include determining the length of the string and identifying the end of the string. The null character is universally recognized as the end of a string and is handled by programming languages.

## Real-Life Applications

### User Interface in Applications
Strings are extensively used in applications to display text, button text, messages, notifications, tooltips, errors, labels, etc.

![Button](button_example.png)
*Example: A button label represented by a string in a web application.*

### Input and Output
Strings play a vital role in taking user input and displaying output after processing.

### Text Processing
Strings are crucial for manipulating and processing textual data, such as searching for substrings, replacing text, and formatting output.

### Web Development
In web development, strings represent HTML, CSS, and JavaScript code. They are used for URLs, handling form data, and creating dynamic web content.

In essence, anything we write in daily life, whether on paper or digital devices, is represented as a string in programming.

## Operations on Strings

 

## Length of String

The length of a string can be determined by looping through the string until the null character appears. This operation has linear time complexity, depending on the number of characters in the string.

```cpp
#include <iostream>
using namespace std;

int stringLength(const char* s) {
    int length = 0;
    while (s[length] != '\0') {
        length++;
    }
    return length;
}

int main() {
    const char* str = "Hello, World!";
    int length = stringLength(str);
    cout << "Length of the string: " << length << endl;
    return 0;
}
```

## Length of a String

In many languages, such as C++, the length of a string can be obtained using built-in functions like `s.size()`.

## Searching in a String

To search for a character in a string, loop through the string and check each individual character. If the desired character is found, return its index; otherwise, return -1. This operation also has linear time complexity.

## Replacing Characters in a String

Replacing characters involves replacing all instances of an old character with a new character in the string. If the old character is not present, the string remains unchanged. This operation has linear time complexity.

## Rotation of a String

String rotation can be either right rotation or left rotation. In right rotation by 'k' bits, each index is shifted to the right by 'k' positions. If any index exceeds the length of the string, it wraps around to the beginning of the string. Right rotation is commonly seen in scenarios like traffic lights and integer overflow handling.

 


 

## Left Rotation

When performing a left rotation of a string by 'k' bits, each index is shifted to the left by 'k' positions. If any index exceeds the length of the string, it wraps around to the end of the string.

## Properties of Strings

### Substrings

A substring is a continuous string extracted from another string. If the starting index is 'i' and the ending index is 'j' (where j >= i), the substring formed by the characters within the range [i, j] is called a substring. If the length of the string is 'n', then the total number of substrings will be n * (n + 1) / 2. Finding substrings of a string can be done by iterating over every index, with a time complexity of O(n^2).

### Subsequences

A subsequence is also a string derived from another string but may not consist of continuous characters. It might even be an empty string. Another term for a subsequence is a subset. For every position in the string, there are two possibilities: either include or exclude that element in the subsequence. A subsequence maintains the order of characters as in the original string. For example, "abcdef" has the subsequences "abdf" (maintains order) and "abfc" (does not maintain order).

 

 

## Linked List

A linked list is a dynamic data structure used to store elements where memory allocation is done randomly rather than contiguously, unlike arrays. Linked lists are especially useful when contiguous memory is not available.

### Difference between Array and Linked List

| Factor            | Array                                           | Linked List                                        |
|-------------------|-------------------------------------------------|----------------------------------------------------|
| Memory Allocation | Contiguous allocation in memory                 | Random allocation in memory                        |
| Memory Type       | Static memory (e.g., Stack memory)              | Dynamic memory (e.g., Heap memory)                |
| Accessing         | Direct access through indices                   | Indirect access, traversal required               |
| Time Complexity   | O(1) constant for direct access                 | O(N) linear due to traversal for access           |
| Dependency        | Elements are independent                        | Each element depends on the previous one           |
| Insertion         | Difficult to insert at a specific position      | Easy to insert at any position                    |
|                   | Time complexity: O(N) for shifting elements     | Insertion at start: O(1), insertion elsewhere: O(N)|
| Deletion          | Difficult to delete, requires shifting elements | Easy to delete, no need to shift elements         |
|                   | Time complexity: O(N) for shifting elements     |                                                    |

In summary, arrays provide direct access but have limitations in dynamic memory allocation and insertion/deletion operations, while linked lists offer flexibility in memory allocation and insertion/deletion operations but require traversal for access.
- 

## Components of Linked List

In a linked list, each element consists of two components:

1. **Data Value:** This component stores the actual data to be stored in the linked list, which can be of any data type such as integer, character, string, or custom data types.

2. **Pointer to the Next Node:** Each element also contains a pointer that points to the address of the next element in the linked list, indicating the location of subsequent elements.

These components together form a node, which is the fundamental building block of a linked list.

### Example C++ Node Class

```cpp
class Node {
public:
    int data;           // Data value stored in the node
    Node* next;         // Pointer to the next node

    Node(int val) {     // Constructor to initialize data value
        data = val;
        next = nullptr;  // Initialize next pointer to null
    }
};
```
## Important Points

- The pointer that points to the starting node of the linked list is called HEAD.
- Optionally, there might be a pointer pointing to the last node of the linked list, known as TAIL.
- The next pointer of the last node points to NULL, indicating the end of the linked list.

## Types of Linked List

There are three main types of linked lists:

1. **Singly Linked List:** Contains only one pointer pointing to the next node. Each node has one data value and points to the next node in the list until the last node, which points to NULL.

Singly linked lists are commonly used in various applications and offer flexibility in data storage and manipulation.
## Circular Linked List

A circular linked list is similar to a singly linked list, with the distinction that the last node in the list points back to the first node, forming a circular cycle. No node points to NULL in this structure. Traversal of the list starting from any node will eventually return to the starting node.

## Doubly Linked List

In a doubly linked list, each node contains two pointers: a "next" pointer that points to the next node in the list, and a "previous" pointer that points to the previous node. Similar to other linked lists, each node also holds a data value. The last node's "next" pointer and the first node's "previous" pointer point to NULL.

### Operations on Linked List

#### Insertion

Insertion involves adding a new element to the linked list at a specified position, which can be:

- At the start of the linked list
- At the end of the linked list
- At any position in between

Lets examine the possible variations:

1. **Insertion at Head (Start of List):**
   - Time Complexity: O(1) Constant

2. **Insertion at Tail (End of List):**
   - Time Complexity: O(N) Linear

3. **Insertion at Any Position Between Nodes:**
   - Time Complexity: O(N) Linear

### Important Observations

When inserting a new node, the previous node (the node before the insertion point) will now point to the new node, and the new node will point to the next node (the node after the insertion point).


```cpp
// Sample C++ code for insertion in a linked list

#include <iostream>
using namespace std;

// Node class for doubly linked list
class Node {
public:
    int data;
    Node* prev;
    Node* next;
    Node(int value) {
        data = value;
        prev = nullptr;
        next = nullptr;
    }
};
```
```cpp
// Doubly Linked List class
class DoublyLinkedList {
public:
    Node* head;
    DoublyLinkedList() {
        head = nullptr;
    }

    // Insertion at the beginning of the list
    void insertAtHead(int value) {
        Node* newNode = new Node(value);
        if (!head) {
            head = newNode;
            return;
        }
        head->prev = newNode;
        newNode->next = head;
        head = newNode;
    }

    // Insertion at the end of the list
    void insertAtTail(int value) {
        Node* newNode = new Node(value);
        if (!head) {
            head = newNode;
            return;
        }
        Node* temp = head;
        while (temp->next) {
            temp = temp->next;
        }
        temp->next = newNode;
        newNode->prev = temp;
    }

    // Insertion at a specified position
    void insertAtPosition(int value, int position) {
        // Logic to insert at a specific position
    }
};

int main() {
    DoublyLinkedList dll;
    dll.insertAtHead(10);
    dll.insertAtTail(20);
    return 0;
}
```

## Deletion

Deletion in a linked list involves removing an element from the list. This can be done by either providing the data value to be deleted, in which case all elements matching that value are removed, or by specifying the position of the element to be deleted, in which case only one element is removed.

- Deletion at the start of the list: O(1)
- Deletion not at the start of the list: O(N)

### Important Observations

When deleting a node, consider the previous node and the next node of the deleted node. Adjust the pointers accordingly to maintain the integrity of the linked list.

```C
// Sample C++ code for deletion in a linked list

#include <iostream>
using namespace std;

// Node structure for the linked list
struct Node {
    int data;
    Node* next;
    Node(int value) {
        data = value;
        next = nullptr;
    }
};

// Function to delete a node at a given position
void deleteNode(Node*& head, int position) {
    if (head == nullptr)
        return;

    Node* temp = head;

    // If position is 0, then delete the head node
    if (position == 0) {
        head = temp->next;
        delete temp;
        return;
    }

    // Find the previous node of the node to be deleted
    for (int i = 0; temp != nullptr && i < position - 1; i++)
        temp = temp->next;

    // If position is more than number of nodes
    if (temp == nullptr || temp->next == nullptr)
        return;

    // Node temp->next is the node to be deleted
    // Store pointer to the next of node to be deleted
    Node* nextNode = temp->next->next;

    // Unlink the node from linked list
    delete temp->next;
    temp->next = nextNode;
}

// Function to print the linked list
void printList(Node* node) {
    while (node != nullptr) {
        cout << node->data << " ";
        node = node->next;
    }
}

// Driver code
int main() {
    Node* head = new Node(1);
    head->next = new Node(2);
    head->next->next = new Node(3);
    head->next->next->next = new Node(4);

    cout << "Original Linked List: ";
    printList(head);
    cout << endl;

    int position = 2; // Delete node at position 2
    deleteNode(head, position);

    cout << "Linked List after deletion at position " << position << ": ";
    printList(head);
    cout << endl;

    return 0;
}

```
 

## Length of the Linked List

Calculating the length of a linked list is straightforward and involves iterating through the list while incrementing a counter until reaching the end of the list.

### Steps:
1. Initialize a temporary pointer and point it to the head/start of the linked list.
2. Increment the pointer to the next node and also increment the value of a length variable initially set to 0.
3. Repeat step 2 until the temporary pointer becomes NULL.

### Code:

```cpp
// Function to calculate the length of a linked list
int lengthOfLinkedList(Node* head) {
    int length = 0;
    Node* temp = head;
    while (temp != nullptr) {
        length++;
        temp = temp->next;
    }
    return length;
}
```

## Real-Life Applications of Linked List

Linked lists find applications in various real-life scenarios due to their flexibility and efficiency in managing dynamic data. Some notable applications include:

### Navigation in Browsers
Forward and backward navigation in web browsers can be implemented using a doubly linked list. Each webpage is represented as a node, allowing users to navigate between pages seamlessly.

### Music and Video Players
Many music and video playing applications use linked lists to manage playlists, play songs, and add favorites. Each song or video is represented as a node in the list, enabling users to insert, delete, or reorder items in the playlist.

### Undo/Redo Functionality
Linked lists are employed in applications that require undo/redo functionality, such as text editors and graphic design software. Each node in the list stores the state of the document at a specific point in time, allowing users to revert changes or redo previous actions.
 

# Stack

Imagine a stack of plates or a pile of notebooks - these are common real-world representations of a stack. A stack is a fundamental data structure that can efficiently solve many interesting problems.
![introduction-to-stacks-1-1700465843](https://github.com/Chandi977/Galgotias-MCA-Study-Material/assets/55855799/66dc126a-add8-4086-b5a5-3b92c32705aa)

## Overview

In a stack, data values are stacked on top of each other. The topmost element is the most recently added, while the bottommost element is the oldest.

![introduction-to-stacks-2-1700465843](https://github.com/Chandi977/Galgotias-MCA-Study-Material/assets/55855799/3660b40a-3e60-48db-95ae-dbfc732409a8)

![introduction-to-stacks-3-1700465844](https://github.com/Chandi977/Galgotias-MCA-Study-Material/assets/55855799/7f643c77-4b4e-44e9-9b88-b4a568f77a88)

![introduction-to-stacks-4-1700465844](https://github.com/Chandi977/Galgotias-MCA-Study-Material/assets/55855799/dfe62d60-1f9e-4f5c-82a2-71c051c88e7a)


### Key Points:

- **LIFO Principle (Last In, First Out):** The element added last will be removed first. Just like a plate placed on top of a stack will be used first.
- **Access Order:** Elements are accessed in reverse order of insertion. The element added first will be accessed last.
- **Operations:**
  - **PUSH:** Add an element to the top of the stack.
  - **POP:** Remove the topmost element from the stack.
  - **TOP:** Get the value of the topmost element.
  - **SIZE:** Get the count of elements in the stack.
  - **EMPTY:** Check if the stack is empty.

## Monotonic Stack

Monotonic stack is a concept where elements in the stack follow a specific order - either increasing or decreasing.

![monotonic-stack-0-1700465926](https://github.com/Chandi977/Galgotias-MCA-Study-Material/assets/55855799/ea365b7b-b3d6-4b46-b8fa-632f65373b35)

![monotonic-stack-1-1700465927](https://github.com/Chandi977/Galgotias-MCA-Study-Material/assets/55855799/37970e68-188f-4d3e-ac52-400e07c83fdb)

### Types:


- **Increasing Monotonic Stack:** Elements increase as we move towards the bottom of the stack. The topmost element is the smallest, and the bottommost is the largest.
- **Decreasing Monotonic Stack:** Elements decrease as we move towards the bottom of the stack. The topmost element is the largest, and the bottommost is the smallest.

Monotonic stacks are useful in various algorithms and problems, especially for finding patterns in data.

The time complexity of stack operations is constant O(1).

